<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta http-equiv="Content-Language" content="en"/>
    <meta name="robots" content="index,follow"/>
    <title>
        
            Pulp Programming
        
    </title>
    <link rel="stylesheet" href="/css/style-pulp.css" media="screen" type="text/css"/>
    <link rel="stylesheet" href="/css/railscasts.css" media="screen" type="text/css"/>
</head>

<body>
    <div class="container">
        <div class="header">
            <a href="/index.html"> Pulp Programming </a>
            <div class="subtitle">
                <p> less of a cathedral, more of a bazaar </p>
            </div>

            <div class="navigation">
                  <a href="/">/home</a>
                  <a href="/pages/archive.html">/archive</a>
                  <a href="/pages/about.html">/about</a>
            </div>
        </div>

        <div class="content">
            

    

    
<h1> <a href="/blog/2013/04/28/Awk-One-Liner.html"> Parsing Gem Versions With Awk </a> </h1>

<div class="date">
    published: 28 Apr 2013
</div>

<p>I installed today latest Ruby (2.0.0-p0) and along with it the smallest gem
versions from the previous Ruby (2.0.0-rc1). Here is awk one-liner that helped
me do that.</p>

<div class="highlight"><pre><code class="bash">chruby 2.0.0-rc1

gem list | <span class="se">\</span>
    awk <span class="s1">&#39;{ gsub(/\(|\)/, &quot;&quot;); line = line &quot; -v=&quot; $NF &quot; &quot; $1; } \</span>
<span class="s1">    END  {print line; }&#39;</span> &gt; gems-versions

chruby ruby-2.0.0-p0
gem install <span class="sb">`</span>cat gems-versions<span class="sb">`</span>
</code></pre>
</div>


<p>First, I switched to ruby-2.0.0-rc1 with 'chruby' in order to make a list of available
gems. Then, I piped list of gems to the awk command in order to parse it. Here is what it does:</p>

<ul>
<li>Remove parenthesis that enclose gem versions in each line with <em>gsub(/\(|\)/, "")</em>.</li>
<li>Concatenate gem version with its name in a single line in the form that the
 <em>gem install</em> command understands (i.e -v=&lt;gem-version> &lt;gem-name>) with
 <em>line=line " -v="$NF" " $1</em>. We take last field (gem version number)
 with <em>$NF</em> and than name of the gem with <em>$1</em> and concatenate that to line
 variable.</li>
<li>Print the concatenated line in the 'gems-versions' file at the end.</li>
</ul>


<p>After I created the list of gems I switched to ruby-2.0.0-p0 and installed gems with:       <em>gem install `cat gems-versions`</em>.</p>

<p>Variations of this are easy. In case that, for instance, we need to install all gem
versions that are already present in the previous Ruby version then awk command
should look probably something like this:</p>

<div class="highlight"><pre><code class="bash">chruby ruby-2.0.0-p0

gem list | <span class="se">\</span>
    awk <span class="s1">&#39;{ gsub(/\)/,&quot;&quot;); gsub(/\(|,\s/, &quot; &quot; $1&quot;:&quot;); \</span>
<span class="s1">    $1=&quot;&quot;; line = line &quot; &quot; $0} END { print line }&#39;</span> &gt; gems-versions

chruby ruby-2.0.0-p0
gem install <span class="sb">`</span>cat gems-versions<span class="sb">`</span>
</code></pre>
</div>


<p>Everything stays the same as in the previous case except we have few additional
awk commands to type:</p>

<ul>
<li>With <em>gsub(/)/,""); gsub(/(|,\s/, " " $1":")</em> we are replacing string
<em>"gem_x (1.0, 2.0)"</em> with "gem_x gem_x:1.0 gem_x:2.0"</li>
<li>Then we are setting the first field (a gem name) to the empty string with
<em>$1=""</em> so we are left with <em>"gem_x:1.0 gem_x:2.0"</em> which should be valid
input for the <em>gem install</em> command.</li>
<li>And last, we concatenate the remaining string <em>$0</em> to the <em>line</em> variable
which will be saved to the <em>gems-versions</em> file.</li>
</ul>





    
        <p> <a href="/blog/2013/04/28/Awk-One-Liner.html#disqus_thread" class="comments">View comments</a> </p>
    



    

    
<h1> <a href="/blog/2013/01/27/Automount-USB-With-Udisks-in-Arch-Linux.html"> Automount With Udisks in Arch Linux </a> </h1>

<div class="date">
    published: 27 Jan 2013
</div>

<p>When it became obvious that <em>systemd</em> was going to replace <em>sysvinit</em> and
<em>init scripts</em> I switched to <em>systemd</em> and experienced several issues in the
process. One of those was that the system couldn't automount usb drives
any more.</p>

<p>Before the transition I used <em>devmon</em> which was started in <em>.xinitrc</em>
before windows manager with <em>ck-launch-session bash -c "devmon &amp; ..."</em>
command and it worked seamlessly. However, after the upgrade
the devmon was broken. No matter whether it was issued manually in
terminal or from the .xinitrc script, it reported the following error:</p>

<div class="highlight"><pre><code class="text">Poll for media failed: Not Authorized
    device: [/dev/sdb1]
    ...
    mountdev /dev/sdb1 DNC vfat
devmon: mount /dev/sdb1 --mount-options noexec,nosuid,noatime    (DNC)
Mount failed: Not Authorized
devmon: error mounting /dev/sdb1 (0)
...
udisks functions are not authorized through policykit,
so devmon cannot automount drives.
...
</code></pre>
</div>


<p>I also tried <em>udiskie</em>, another automatic disk mounter that uses
<em>udisks</em>, and it failed to mount disk with the similar message:</p>

<div class="highlight"><pre><code class="text">attempting to mount device /org/freedesktop/UDisks/devices/sdb1 (vfat:[])
failed to mount device /org/freedesktop/UDisks/devices/sdb1:
  org.freedesktop.UDisks.Error.PermissionDenied: Not Authorized
</code></pre>
</div>


<p>Obviously the problem was not <em>devmon</em>, nor <em>udiskie</em>. Somehow <em>udisks</em> functions
were no longer authorized through <em>policykit</em>... It was clear that I should
famialirize myself with <em>polkit</em> and find out how to authorize <em>udisks</em> actions.</p>

<p>From <em>polkit(8)</em> manpages I learned that in order to authorize
disk mounting I should write <em>polkit</em> rule. These rules are placed in
<em>/etc/polkit-1/rules.d/</em> and <em>/usr/share/polkit-1/rules.d/</em> directories in
files with <em>.rules</em> extension. Both directories are monitored by <em>polkitd</em>
process. If rule is changed, added or removed all rules are processed
again.</p>

<p>So I added <em>/etc/polkit-1/rules.d/10-udisks-automount.rules</em> file with
the following rule:</p>

<div class="highlight"><pre><code class="javascript"><span class="nx">polkit</span><span class="p">.</span><span class="nx">addRule</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">action</span><span class="p">,</span> <span class="nx">subject</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="nx">id</span> <span class="o">==</span> <span class="s2">&quot;org.freedesktop.udisks.filesystem-mount&quot;</span> <span class="o">&amp;&amp;</span>
                <span class="nx">subject</span><span class="p">.</span><span class="nx">isInGroup</span><span class="p">(</span><span class="s2">&quot;storage&quot;</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">polkit</span><span class="p">.</span><span class="nx">Result</span><span class="p">.</span><span class="nx">YES</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">});</span>
</code></pre>
</div>


<p>Basically it says that <em>udisks</em> mount action should be allowed to the users
in the <em>storage</em> group. Values for <em>action.id</em> as well as other information
about <em>polkit</em> authorization policies can be found in <em>/usr/share/polkit-1/actions</em>
directory. Particularly, the policy for the <em>udisks</em> is placed in
<em>org.freedesktop.udisks.policy</em> file. All rules are written in JavaScript.</p>

<p>After I'd added this rule, <em>devmon</em> and <em>udiskie</em> started to work as expected
so I haven't searched further. For that reason I suppose that what I've presented
here is probably quick and dirty solution. It should serve just as a remainder
to me in the future and it might also help someone with the similar problem.
More comprehensive coverage of <em>udev</em>, <em>udisks</em> and <em>polkit</em> can be found on the
<a href="https://wiki.archlinux.org/index.php/Udev#Udisks">Arch wiki pages for udev</a>
and with <em>man polkit(8)</em>.</p>




    
        <p> <a href="/blog/2013/01/27/Automount-USB-With-Udisks-in-Arch-Linux.html#disqus_thread" class="comments">View comments</a> </p>
    



    

    
<h1> <a href="/blog/2012/09/08/Browse-and-change-code-with-Git.html"> Browse and change code history with Git </a> </h1>

<div class="date">
    published: 08 Sep 2012
</div>

<p>Sometimes, if I really want to understand a peace of software, I embark on browsing its whole history available in Git. I usually checkout its initial commit and than slowly make my way through the forest of subsequent commits and branches. If the project is the important one and has live and vibrant community I also consult mailing list archives for the point of time when a particular commit is made. This way, not only that I learn what were the original driving ideas of the current design, but often I gain deep insights about evolution and dynamics of the project .</p>

<p>I'll write now about some Git commands from its time-traveling-and-history-changing toolbox that I use in this setting.</p>

<p>Let's assume the following history exists and the current branch is "develop":</p>

<div class="highlight"><pre><code class="text">               A---B---C---D---E---X develop
</code></pre>
</div>


<p>Now let's say that I'm on commit B where some particularly complicated algorithm is introduced. As I have hard time understanding the algorithm I write lots of printf's, comments and proof-of-concept code all over the place. Also, I often try to do the same thing that is done in the code differently and sometimes (especially when I make a mistake) I see why the author had chosen the particular way of doing it.</p>

<p>This meta-code helps me to really understand the original source and forces me to learn and adopt good practices and ideas from it. It has a tremendous value for me because if I need to check the algorithm at the point B again I will, hopefully, understand it and know how to reuse it much more quickly with this meta-code explanations. As I want to preserve this for the future I create commits along the way and usually group them in separate 'code-review' branch.</p>

<div class="highlight"><pre><code class="text">git checkout -b code-review &lt;B-sha1&gt;
</code></pre>
</div>


<p>Next, I write explanatory comments, log messages and tests for commit B in commits F, G, H on the code-review branch so my git repository looks something like this</p>

<div class="highlight"><pre><code class="text">                     F---G---H code-review
                    /
               A---B---C---D---E---X develop
</code></pre>
</div>


<p>When I'm done with reviewing commit B I move further down the main developing line to commits C, D, and E. Let's say the code there consists just of smaller tweaks of the algorithm that is introduced at the point B. I understand everything without need to write additional meta-code and I want to integrate them in my code-review branch so I can move on to another commits down the develop branch.</p>

<p>The easiest way to integrate C, D and E with <em>all</em> previous code-review commits (F, G, H) is to use git <em>rebase</em> command (at this point I would be in 'code-review' branch):</p>

<div class="highlight"><pre><code class="text">git rebase &lt;E-sha1&gt;
</code></pre>
</div>


<p>So I end up with the following repository:</p>

<div class="highlight"><pre><code class="text">                                 F---G---H code-review
                                /
               A---B---C---D---E---X develop
</code></pre>
</div>


<p>However, let's say I want to integrate only commits F and G with the C, D, and E from the develop branch. In that case I would use git <em>rebase</em> with --onto option as follows:</p>

<div class="highlight"><pre><code class="text">git rebase --onto &lt;E-sha1&gt; &lt;B-sha1&gt; &lt;G-sha1&gt;
git checkout -b temp
git checkout code-review
git reset --hard temp
git branch -d temp
</code></pre>
</div>


<p>The first command basically says <em>move all commits between B (not including it) and G (including it) onto E commit</em>. After <em>rebase</em> is successfully finished the repository should look like this:</p>

<div class="highlight"><pre><code class="text">                       F---G---H code-review
                      /
                     /           F---G (no-branch)
                    /           /
               A---B---C---D---E---X develop
</code></pre>
</div>


<p>There is a new (no-branch) HEAD that is in so called <em>detached</em> state.
In other words it's simply a commit hash which isn't pointed to by a tag or a branch.
Basically, whenever you check out a non-referenced head, you end up with a detached
head. In practice some conflicts may arise at this stage. To efficiently resolve them I recommend <a href="https://github.com/jwiegley/git-scripts/blob/master/git-rm-conflicts">git-rm-conflicts</a> script written by John Wiegley.</p>

<p>Next I create <em>'temp'</em> branch to point to detached HEAD, and then checkout to <em>'code-review'</em>. The <em>'code-review'</em> branch pointer is then forcibly moved with <em>git reset --hard temp</em> to point to the same place as <em>'temp'</em>. At the end <em>'temp'</em> branch is deleted
so final repository should look like this:</p>

<div class="highlight"><pre><code class="text">                                 F---G code-review
                                /
               A---B---C---D---E---X develop
</code></pre>
</div>


<p>And for the end, here is the script that is very handy for reviewing branches and project history:</p>

<div class="highlight"><pre><code class="text">git log &lt;B-sha1&gt;^..HEAD --graph --decorate --pretty=oneline \
    --abbrev-commit develop code-review some-other-branch
</code></pre>
</div>


<p>You can add <em>-p</em> to see detailed diffs, leave off <em>--pretty=...</em> to see whole log messages, or tweak it some other way to suit your needs.</p>




    
        <p> <a href="/blog/2012/09/08/Browse-and-change-code-with-Git.html#disqus_thread" class="comments">View comments</a> </p>
    




<div class="leftright">
    

    
        <div class="right">
            <a href="/page2/index.html"> Previous entries </a> &raquo;
        </div>
    
</div>




        </div>
        <div class="push"></div>
    </div>
    <!--
<div class="footer">
    <div>
        <h1> Archives </h1>
        <ul>
            <li> <a href="/archives.html">Archives</a> </li>
        </ul>
        <br/>
    </div>

    <div>
        <h1> Meta </h1>
        <ul>
            <li> <a href="/atom.xml">RSS</a> </li>
            <li> <a href="http://validator.w3.org/check?uri=referer">Valid XHTML 1.0</a> </li>
            <li> <a href="http://jigsaw.w3.org/css-validator/check/referer">Valid CSS</a> </li>
        </ul>
    </div>

    <div>
      <h1> Blogroll </h1>
        <ul>
            <li> <a href="https://github.com/">Github</a> </li>
            <li> <a href="https://github.com/mojombo/jekyll/">Jekyll Home</a> </li>
            <li> <a href="http://pages.github.com/">Pages tutorial</a> </li>
        </ul>
    </div>
</div>

 -->
    <div class="copyright">
        Powered by
        <a href="https://github.com/mojombo/jekyll/wiki">Jekyll</a> and
        <a href="http://www.heroku.com/">Heroku</a>
    </div>
</body>
</html>

